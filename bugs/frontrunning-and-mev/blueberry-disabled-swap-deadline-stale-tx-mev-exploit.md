# Blueberry Protocol - Disabled Deadline Enables Stale Swaps & MEV Exploitation

* **Severity**: High
* **Source**: [Sherlock Audits](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/145)
* **Affected Contract**: [CurveSpell.sol](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L162-L175)
* **Vulnerability Type**: Missing Deadline / Slippage Bypass / MEV & Price-Manipulation Exposure

## Summary

Blueberry's spell contracts perform token swaps without enforcing any **transaction deadline**, using `type(uint256).max` as the swap deadline—or in some cases, using a pool swap function that **has no deadline parameter at all**.

Because of this, any swap transaction can remain pending in the mempool for **hours, days, or weeks**, and still execute—long after its slippage assumptions become outdated.

This exposes users to **unexpected bad trades**, **high slippage**, and **MEV sandwich attacks**, since bots can target the stale transaction knowing it has no expiration.

## A Better Explanation (With Simplified Example)

### Intended Behavior

AMMs (Uniswap V2, V3, Sushiswap, Curve routers, etc.) allow the user to provide a **deadline**:

* "If this trade doesn't execute in the next 2 minutes, cancel it."

This protects users from:

1. **Delayed mempool execution**
2. **Price changes after transaction signing**
3. **MEV bots exploiting stale slippage settings**

Correct usage example:

```solidity
swapRouter.swapExactTokensForTokens(
    amountIn,
    minOut,
    path,
    to,
    userProvidedDeadline   // expires soon
);
```

### What Actually Happens in Blueberry (Bug)

#### 1) CurveSpell: deadline = max uint256

```solidity
swapRouter.swapExactTokensForTokens(
    rewards,
    0,
    swapPath,
    address(this),
    type(uint256).max   // no deadline enforced
);
```

`type(uint256).max` means:

> "This trade can execute **forever**, with no expiration."

#### 2) ChiSpell: swap uses pool directly — no deadline at all

```solidity
SWAP_POOL.swap(
    address(this),
    !isTokenA,
    amountToSwap.toInt256(),
    sqrtRatioLimit +/- deltaSqrt, // slippaged price cap
    abi.encode(address(this))
);
```

The pool-level SWAP has **no deadline parameter**, so swaps never expire.

## Why This Matters

Because swaps never expire:

* A user's transaction might sit in the mempool for a **very long time**.
* When it finally executes, market prices may be drastically different.
* The user's old **minOut / slippage constraints** make no sense anymore.
* MEV bots can detect the stale transaction and **profitably sandwich it**.

This results in:

* **Unexpectedly bad execution prices**
* **Excess slippage**
* **Significant user loss**
* **No ability to safely cancel stale pending transactions**

## Concrete Walkthrough (Alice & MEV Bot)

### 1. Alice submits a swap

She swaps:

* 100 BBY Tokens → ETH

Gas prices spike, so her tx stays in mempool.

Alice forgets about it.

### 2. After 5 hours, market changes

* ETH price dropped 12%
* Her slippage settings are now completely outdated

Because Blueberry used:

```solidity
deadline = type(uint256).max
```

the trade is still "valid forever".

### 3. MEV bot notices the stale tx

Bot sees:

* outdated slippage tolerance
* huge potential for profitable price manipulation

Bot executes a **sandwich attack**:

1. Front-runs Alice → pushes price against her
2. Alice executes her stale swap with awful slippage
3. Bot back-runs → takes profits

Alice receives much less ETH than she expected.

### 4. Alice unknowingly suffers a large loss

She believes the transaction expired long ago — but it didn't.

## Vulnerable Code Reference

### 1) CurveSpell uses a max-uint deadline

```solidity
swapRouter.swapExactTokensForTokens(
    rewards,
    0,
    swapPath,
    address(this),
    type(uint256).max
);
```

### 2) ChiSpell swaps directly on the pool (no deadline parameter)

```solidity
SWAP_POOL.swap(
    address(this),
    !isTokenA,
    amountToSwap.toInt256(),
    sqrtRatioLimit +/- deltaSqrt,
    abi.encode(address(this))
);
```

### 3) Sponsor comment on incorrect proposed fix

> "This fix does not address this issue.
> Since block.timestamp is always relative, using it in any way is equivalent to using no deadline at all.
> Needs to use a user-defined input to effectively enforce any deadline."

## Recommended Mitigation

### 1. Require user-provided deadline (primary fix)

Add a `deadline` parameter to spell functions:

```solidity
function closePositionFarm(..., uint256 deadline) external { ... }
```

And pass it directly through:

```solidity
swapRouter.swapExactTokensForTokens(
    rewards,
    0,
    swapPath,
    address(this),
    deadline
);
```

The **user**, not the contract, chooses the expiration.

### 2. Add deadline support to direct pool swaps (ChiSpell)

Wrap the pool swap in logic that rejects execution when no longer valid:

```solidity
require(block.timestamp <= userDeadline, "Deadline exceeded");
```

---

### 3. Enforce strict slippage checks

If slippage inputs are old:

* reject the call
* require users to resubmit with fresh slippage limits

---

### 4. Document best practices for frontends

Frontends should pre-fill:

* `deadline = block.timestamp + 2-5 minutes`

## Pattern Recognition Notes

* **Missing Expiration Mechanisms**
  Any swap or liquidity action without a deadline is vulnerable to stale execution.

* **AMM Interaction Risks**
  Slippage tolerance becomes meaningless once enough time passes.

* **Mempool Time Lag + MEV**
  Stale pending transactions attract sandwich bots, especially when prices move.

* **User Assumption Mismatch**
  Users expect transactions to "fail fast", but without deadlines they remain valid indefinitely.

* **Invalid Fixes (block.timestamp)**
  A contract-supplied timestamp cannot enforce expiry; only user-supplied deadlines work.

## **Quick Recall (TL;DR)**

* **Bug:** Swaps use `uint256.max` or no deadline → meaning swaps can execute any time in the future.
* **Impact:** Stale transactions can be executed at bad prices or sandwiched by MEV bots → severe user losses.
* **Fix:** Require **user-provided deadlines** and apply them consistently across all swap paths.
