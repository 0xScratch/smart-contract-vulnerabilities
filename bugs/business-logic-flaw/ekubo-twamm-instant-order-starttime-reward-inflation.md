# TWAMM Instant Orders Can Steal Historical Rewards via Start-Time Boundary Bug

* **Severity**: Medium
* **Source**: [Code4rena](https://code4rena.com/audits/2025-11-ekubo/submissions/F-113)
* **Affected Contract**: [TWAMM.sol](https://github.com/code-423n4/2025-11-ekubo/blob/bbc87eb26d73700cf886f1b3f06f8a348d9c6aef/src/extensions/TWAMM.sol#L84-L111)
* **Vulnerability Type**: Business Logic Flaw / Accounting Error / Time Boundary Bug

## Summary

The TWAMM extension relies on **time-based reward snapshots** to ensure that each order only earns rewards generated *after* its `startTime`. However, when a TWAMM order is created with `startTime == block.timestamp`, the contract fails to properly anchor the order's reward baseline.

This causes `rewardRatesBeforeSlot[startTime]` to remain uninitialized (zero), and due to an incorrect boundary condition in `getRewardRateInside()`, the order experiences a **discrete reward jump** that includes **all historical rewards accumulated before the order existed**.

An attacker can exploit this by creating a small "instant" TWAMM order at the precise boundary and then collecting first, draining the shared reward pool and preventing legitimate orders from collecting.

## A Better Explanation (With Simplified Example)

### Intended Behavior

TWAMM rewards are designed to behave like Uniswap-style "fees per liquidity":

1. The pool maintains a **monotonically increasing reward rate**.
2. When an order starts at `startTime`, the pool records a **reward snapshot** for that time.
3. The order's reward is computed as:

    ```ini
    reward = rewardRateNow − rewardRateAtStartTime
    ```

4. This ensures:
    * No order can earn rewards from *before* it existed.
    * Rewards grow smoothly over time.

### What Actually Happens (Bug)

The logic that registers order start times and the logic that calculates rewards disagree on **boundary conditions**.

#### 1. Start-time registration logic

In `handleForwardData()`:

```solidity
if (block.timestamp < startTime) {
 // Register startTime and endTime
 _updateTime(poolId, startTime, saleRateDelta, isToken1, numOrdersChange);
 _updateTime(poolId, endTime, -int256(saleRateDelta), isToken1, numOrdersChange);
} else {
 // block.timestamp >= startTime
 // Only endTime is registered
 _updateTime(poolId, endTime, -int256(saleRateDelta), isToken1, numOrdersChange);
}
```

When `block.timestamp == startTime`:

* The code enters the `else` branch
* `startTime` is **never registered**
* `rewardRatesBeforeSlot[startTime]` is never initialized

#### 2. Reward calculation logic

In `getRewardRateInside()`:

```solidity
} else if (block.timestamp > config.startTime()) {
    rewardRateCurrent - rewardRateStart;
}
```

Key detail:

* The condition is `>` instead of `>=`

This creates a **one-second window** where:

* At `t == startTime`: reward = 0 (correct)
* At `t > startTime`: reward suddenly becomes `rewardRateCurrent − 0`

This produces a **non-continuous jump** in rewards.

### Why This Matters

* TWAMM rewards are **shared across all active orders**
* The attacker's order illegitimately claims **historical rewards**
* When the attacker collects first:

  * The pool's saved balances are depleted
  * Legitimate orders revert on collection (`SavedBalanceOverflow`)
* A very small order can steal rewards generated by much larger historical orders

### Concrete Walkthrough (Victim & Attacker)

#### Setup

* Pool already executed TWAMM orders
* `poolRewardRatesSlot` contains historical reward growth

#### Victim

* Sells `100e18` token0 over a normal TWAMM interval
* Rewards accrue correctly

#### Attacker

* Waits for a timestamp where `block.timestamp % 256 == 0`
* Creates a TWAMM order with:

  ```yaml
  startTime == block.timestamp
  ```

* Sells only `1e18` token0

#### Exploit

1. `startTime` snapshot is never written
2. After 1 second:

   ```yaml
   rewardRateInside = rewardRateCurrent − 0
   ```

3. Attacker claims **all historical rewards**
4. Victim attempts to collect → **reverts**, pool drained

> **Analogy**: A shared reward meter resets at scheduled checkpoints. The attacker joins exactly at a checkpoint that wasn't recorded, so the meter appears to have always belonged to them.

## Vulnerable Code Reference

### 1) Missing startTime registration when `block.timestamp == startTime`

```solidity
if (block.timestamp < startTime) {
    _updateTime(poolId, startTime, saleRateDelta, isToken1, numOrdersChange);
} else {
    // startTime is skipped entirely
}
```

### 2) Incorrect boundary condition in reward calculation

```solidity
// getRewardRateInside()
} else if (block.timestamp > config.startTime()) {
    result = rewardRateCurrent - rewardRateStart;
}
```

Should handle `>= startTime` to prevent a discrete jump.

## Recommended Mitigation

### 1. Always register `startTime` (Recommended)

Ensure `rewardRatesBeforeSlot[startTime]` is initialized even when the order starts immediately:

```solidity
_updateTime(poolId, startTime, 0, isToken1, 0);
```

This preserves reward continuity without altering sale rates.

### 2. Fix boundary condition in `getRewardRateInside`

```solidity
} else if (block.timestamp >= config.startTime()) {
```

This ensures reward growth begins *from* startTime, not after a gap.

### 3. Defensive invariant testing

Add tests asserting:

* Reward growth is **continuous** across `startTime`
* No order can observe historical rewards
* `rewardRateInside(startTime + 1) ≈ 0` for newly created orders

## Pattern Recognition Notes

* **Time-Boundary Bugs**: `>` vs `>=` errors are extremely dangerous in time-based accounting.
* **Implicit Invariants**: "Reward growth must be continuous" was assumed but never enforced.
* **Snapshot Accounting Pitfalls**: Any system using `(current − snapshot)` is vulnerable if snapshots can be skipped.
* **Discrete Time Systems**: When logic relies on aligned time buckets (e.g., 256s), exact-equality cases must be handled explicitly.
* **Environment Sensitivity**: A bug may be infeasible on L1 but exploitable on L2s with different timestamp behavior.

## Quick Recall (TL;DR)

* **Bug**: Orders created at `startTime == block.timestamp` miss their reward snapshot.
* **Effect**: Reward calculation jumps and includes historical rewards.
* **Impact**: Attacker drains shared TWAMM rewards; victims cannot collect.
* **Fix**: Always register `startTime` and use `>=` in reward growth logic.
