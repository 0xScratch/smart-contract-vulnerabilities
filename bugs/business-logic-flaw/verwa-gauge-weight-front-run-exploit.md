# Extra Gauge Weight via Front-Running Governance Overrides in GaugeController

- **Severity**: Medium
- **Source**: [Code4rena](https://github.com/code-423n4/2023-08-verwa-findings/issues/294) / [One Bug Per Day](https://www.onebugperday.com/v1/512)
- **Affected Contract**: [GaugeController.sol](https://github.com/code-423n4/2023-08-verwa/blob/main/src/GaugeController.sol)
- **Vulnerability Type**: Business Logic Flaw / Race Condition

## Original Bug Description

>## Lines of code
>
>[https://github.com/code-423n4/2023-08-verwa/blob/main/src/GaugeController.sol#L204](https://github.com/code-423n4/2023-08-verwa/blob/main/src/GaugeController.sol#L204)
>
>## Vulnerability details
>
>## Impact
>
>Users can get extra voting power by front-running calls to `change_gauge_weight`
>
>## Proof of Concept
>
>It can be expected that in some cases calls will be made to `change_gauge_weight` to increase or decrease a gauge's weight. The problem is users can be monitoring the mempool expecting such calls. Upon seeing such, any people who have voted for said gauge can just remove their vote prior to `change_gauge_weight`. Once it executes, they can vote again for their gauge, increasing its weight more than it was expected to be:
>
>Example:
>
>1. Gauge has 1 user who has voted and contributed for 10_000 weight
>2. They see an admin calling `change_gauge_weight` with value 15_000.
>3. User front-runs it and removes all their weight. Gauge weight is now 0.
>4. Admin function executes. Gauge weight is now 15_000
>5. User votes once again for the gauge for the same initial 10_000 weight. Gauge weight is now 25_000.
>
>Gauge weight was supposed to be changed from 10_000 to 15_000, but due to the user front-running, gauge weight is now 25_000
>
>## Tools Used
>
>Manual review
>
>## Recommended Mitigation Steps
>
>Instead of having a set function, use increase/ decrease methods.
>
>## Assessed type
>
>Other
>
>## Additional PoC (Mentioned in Comments)
>
>```solidity
>    function testWithFrontRun() public { 
>        vm.startPrank(gov);
>        gc.add_gauge(gauge1);
>        gc.change_gauge_weight(gauge1, 0);
>        vm.stopPrank();
>
>        vm.startPrank(user1);
>        ve.createLock{value: 1 ether}(1 ether);
>        gc.vote_for_gauge_weights(gauge1, 10000);
>        uint weight = gc.get_gauge_weight(gauge1);
>        console.log("gauge's weight after voting: ", weight);
>        vm.stopPrank();
>
>        vm.prank(user1);
>        gc.vote_for_gauge_weights(gauge1, 0); // front-run transaction by user
>        vm.prank(gov);
>        gc.change_gauge_weight(gauge1, 1000000000000000000);
>
>        vm.startPrank(user1);
>        gc.vote_for_gauge_weights(gauge1, 10000); // back-run
>        weight = gc.get_gauge_weight(gauge1);
>        console.log("gauge's weight after changing weight: ", weight);
>        vm.stopPrank();
>    }
>
>        function testWithoutFrontRun() public { 
>        vm.startPrank(gov);
>        gc.add_gauge(gauge1);
>        gc.change_gauge_weight(gauge1, 0);
>        vm.stopPrank();
>
>        vm.startPrank(user1);
>        ve.createLock{value: 1 ether}(1 ether);
>        gc.vote_for_gauge_weights(gauge1, 10000);
>        uint weight = gc.get_gauge_weight(gauge1);
>        console.log("gauge's weight after voting: ", weight);
>        vm.stopPrank();
>
>        vm.prank(gov);
>        gc.change_gauge_weight(gauge1, 1000000000000000000);
>
>        weight = gc.get_gauge_weight(gauge1);
>        console.log("gauge's weight after government changes weight: ", weight);
>    }
>```
>
>```logs
>[PASS] testWithFrontRun() (gas: 702874)
>Logs:
>  gauge's weight after voting:  993424657416307200
>  gauge's weight after changing weight:  1993424657416307200
>```
>
>```logs
>[PASS] testWithoutFrontRun() (gas: 674264)
>Logs:
>  gauge's weight after voting:  993424657416307200
>  gauge's weight after government changes weight:  1000000000000000000
>```

## Summary

The `GaugeController` contract allows governance to **set** a gauge's weight for the next epoch via `change_gauge_weight()`. However, users can **front-run** this governance action by temporarily removing their votes (`vote_for_gauge_weights(gauge, 0)`), letting the admin set the new weight, then **back-running** their original vote. This yields an unintended cumulative weight:

- Intended: gauge weight changes from 10 000 bps → 15 000 bps (Δ + 5 000).
- Actual: gauge weight changes from 10 000 bps → 25 000 bps (Δ + 15 000) due to user vote stacking.

## A Better Explanation (With Simplified Example)

### Understanding Gauges, Weights, and Bias First

- **Gauge:** Think of a gauge as a project or asset pool that can receive rewards from the protocol — for example, a real-world asset lending pool.
- **Voting Power and VotingEscrow:**
Users lock tokens in the VotingEscrow contract for a certain time to gain voting power. This voting power decays linearly over time — meaning the longer you lock tokens, the more voting power you have initially, but it gradually decreases as the lock approaches end.
- **Votes and Voting Weight:**
Each user can allocate a percentage of their own voting power across different gauges, expressed in **bps** (basis points, where 10,000 bps = 100%). The sum of all users' votes for a gauge aggregates to the gauges **weight**, which determines how much reward that gauge will receive.
- **Bias:**
In the contract, **bias** is a measure of the *current total voting power allocated* to a gauge at a given time (adjusted for decay). Bias essentially represents a gauge's "weight" or "influence" on the reward distribution during a particular epoch (week).

### How Governance Can Override Gauge Weights

- The admin (governance) can call `change_gauge_weight(gauge, newWeight)` to **set** the gauge's total voting power (bias) for the next week directly. This forcibly overwrites the gauge's weight, regardless of what users voted.
- The contract sets the gauge's bias to `newWeight` at the start of the upcoming week, and adjusts the global total accordingly.

### The Front-Running Vulnerability Explained

Because governance **sets the gauge weight absolutely**, ignoring existing user votes for that next epoch, users can exploit this:

1. **Normal State:**
A user has voted for a gauge, contributing some voting power (say, equivalent to bias = 10,000).
2. **Governance Intends to Change Weight:**
Governance plans to increase the gauge weight to 15,000 for the next week by calling `change_gauge_weight`.
3. **User Front-Runs Governance's Call:**
The user calls `vote_for_gauge_weights(gauge, 0)` just before governance's transaction is mined, removing their voting power from the gauge (bias drops to 0).
4. **Governance's Call Executes:**
The gauge's bias is forcibly set to 15,000 by governance.
5. **User Back-Runs:**
The user votes again with full power (bias of 10,000). Because the gauge bias was set without considering the user's vote, the gauge bias becomes 15,000 + 10,000 = 25,000 instead of the intended 15,000.

### Why Is This a Problem?

- The effective gauge weight for rewards becomes larger than governance intended.
- Users can **artificially inflate** their gauge's weight by temporarily removing and re-adding votes sandwiching governance's weight change.
- This breaks fair and predictable reward allocation logic, allowing exploitation.

### Simple Example Timeline

| Time | Action | Gauge Bias Before | Gauge Bias After |
| :-- | :-- | :-- | :-- |
| T0 | User votes for gauge, gauge bias = 10,000 | 0 | 10,000 |
| T1 | Governance plans weight change to 15,000 | 10,000 | (pending) |
| T2 | User front-runs by removing votes (bias = 0) | 10,000 | 0 |
| T3 | Governance executes weight override to 15,000 | 0 | 15,000 |
| T4 | User back-runs by voting full power again | 15,000 | 25,000 |

## Vulnerable Code Reference

```solidity
// GaugeController.sol
function change_gauge_weight(address _gauge, uint256 _weight) public onlyGovernance {
    _change_gauge_weight(_gauge, _weight);
}

function _change_gauge_weight(address _gauge, uint256 _weight) internal {
    uint256 old_gauge_weight = _get_weight(_gauge);
    uint256 old_sum = _get_sum();
    uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;

    // Absolute assignment of bias for next epoch
    points_weight[_gauge][next_time].bias = _weight;
    time_weight[_gauge] = next_time;

    uint256 new_sum = old_sum + _weight - old_gauge_weight;
    points_sum[next_time].bias = new_sum;
    time_sum = next_time;
}
```

## Recommended Mitigation

1. **Use Relative Adjustments**
Replace `change_gauge_weight` with incremental functions:

    ```solidity
    function increase_gauge_weight(address _gauge, uint256 delta) internal { … }
    function decrease_gauge_weight(address _gauge, uint256 delta) internal { … }
    ```

    These should add/subtract from the existing bias for the next epoch, preventing vote stacking.

2. **Reconcile with User Votes**
When governance overrides weights, automatically adjust or burn any excess user voting power to maintain intended Δ.
3. **Mempool Protection**
Introduce a short delay or timelock for governance weight changes to reduce front-running risk.
4. **Event Emission and Monitoring**
Emit detailed events for weight changes so off-chain monitoring can detect and alert rapid vote withdrawals.

## Pattern Recognition Notes

- **Unconditional State Overwrites by Governance**
  - Check for functions where governance or privileged roles can directly overwrite weighted or vote-related state without reconciling existing user contributions, increasing the risk of inconsistent or inflated state.

- **Interplay Between Governance Overrides and User Voting**
  - Scrutinize how contracts combine governance-set parameters with user-driven inputs. Lack of mechanisms to merge or reconcile governance overrides with ongoing user votes can lead to manipulation or duplication of influence.

- **Front-Running & Transaction Ordering Risks**
  - Identify points where users might monitor pending governance transactions and react (e.g., by temporarily withdrawing and re-adding votes) to influence final outcomes. Lack of timing protections or atomic updates invites such race conditions.

- **Use of Absolute vs. Incremental Updates**
  - Absolute assignments to critical variables (like total gauge weight) are more prone to exploits vs. incremental increase/decrease functions, which better preserve state consistency and prevent stacking attacks.

- **Epoch or Checkpoint-Based State Updates**
  - Systems that update weights or votes at discrete time intervals must ensure that governance actions cannot be "sandwiched" between user votes during checkpoints to cause unintended cumulative effects.

- **Transparency & Monitoring Gaps**
  - Insufficient event logging or unclear update flows limit off-chain monitoring capabilities, making it harder to detect suspicious voting or governance patterns indicative of exploitation.

- **User Voting Power Accounting Edge Cases**
  - Audit how the contract tracks sums of user voting power and their allocations; incomplete accounting or failure to handle intermediate vote removals may create exploitable inconsistencies.

- **Cross-Function State Consistency**
  - Verify that all functions modifying voting power or gauge weights perform consistent reconciliation of old and new states, preventing stale data accumulation or vote duplication.
